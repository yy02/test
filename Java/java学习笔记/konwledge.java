/*
 *  
        int的默认值是0，Integer的默认值是null
 
 
 * 父类可以接收所有子类的方法
 * 
 * 小的类型可以自动转换成大的数据类型，大的数据类型需要强制转换编程小的数据类型
 * 子类到父类的类型转化可以直接进行，父类到子类需要强制转换
 * 
 *	 ==	在比较对象时必须指向同一个对象才是true，比较双方必须同一类型
 * 	equals 只能比较引用类型，是否指向同一个对象
 * 			特殊：比较类型内容而不考虑是否是同一个对象dat、string、file
 * 
 * 包装类：把基本数据类型包装成包装类/叫做装箱
 * 			/拆箱  / intValue();用来拆箱
 * 			
 * 			自动装箱/自动拆箱 Integer i = 112;/int i1= i;
 * 		大写装箱，小写拆箱
 * 		基本数据类型的包装类主要就是做基本数据类型与字符串之间的转换
 * 
 * 
 * 		如果希望某些属性不会根据对象的不同而改变就设置成类属性
 * 			方法与调用者无关叫做类方法，就是静态的方法，一般在工具类中用的多
 * 
 * 
 * 		this 和super 是针对对象的，static针对类的，所以在static中无法使用
 * 		在static方法中只能调用static修饰的属性或者对象
 * 
 * 
 * 
 * 
 * 
 * 
 *	单例模式：软件运行 只有一个实例化对象
 *		在整个软件系统运行中只（new）实例化一次，然后不论在哪都只调用折一个实例
 * 		一般使用单例模式解决new对象费劲或者频繁new新对象的问题
 * 		1.饿汉式单例模式 		一开始直接new一个对象等待调用
 * 		2.懒汉式单例模式		第一个调用完后new了一个对象，之后直接用
 * 
 * 
 * 	模板方法设计模式
 * 		父类中编写了子类的通用方法，并把一个或者多个方法留给子类实现
 * 
 * 	工厂方法设计模式
 * 		
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 	静态代码块static{}  和非静态代码块{   }   的区别就是静态代码块只执行一次
 * 		在程序运行中，非静态代码块每次new对象都要执行一次，而静态代码块只执行一次
 * 		优先级 静态代码块先执行，然后非静态代码块，然后执行方法
 * 
 * 
 * 
 * 	final修饰的变量或者类或者方法是不变的，不能被重写，不能被继承
 * 	final修饰的变量是常量，必须显式赋值，只能赋值一次，不能再改变
 * 	
 * 	
 * 	抽象类
 * 		用abstract修饰类或者方法，声明方法时，只有声明，没有实现，就是没有代码块。含有抽象方法的类必须是抽象类。
 * 		抽象类不能被实例化，只能作为父类被继承，然后由子类来重写父类的全部的抽象方法，并提供方法体
 * 
 * 
 * 	
 * 
 * 
 * 	接口是一种特殊的抽象类
 * 		接口中所有的变量都是默认public static final修饰的
 * 			所以的方法都是默认public abstract修饰的
 * 			没有构造器。多层继承
 * 		类可以实现多个接口，如果一个类没有实现接口的方法就需要定义成抽象类
 * 		一个类既继承了父类，有时限接口，那么先集成，后实现
 * 			
 * 
 * 		
 * 抽象类和接口：
 * 		抽象类是对一类事物的高度抽象，其中既有属性，也有方法
 * 		接口是对方法的抽象，就是对一系列动作的抽象
 * 	当需要对一类事物进行抽象的时候使用抽象类来形成父类
 * 	当需要对一系列动作进行抽象的时候就使用接口，需要使用这些动作的类去实现相应的接口
 * 
 * 
 * 
 * 
 * 		内部类：
 * 			在类中写的类可以调用所属类的变量
 * 			可以声明为final、static、protect、priva
 * 			可以写多个
 * 			如果内部类是static的，那么外部的不是static的属性内部类无法使用
 * 		主要是为了解决java不能多重继承的问题
 * 
 * 
 * 		父类抛出了异常
 * 			子类在重写父类方法的时候也要抛出异常，但是不能抛出比父类范围更大的异常
 * 			可以用try{}catch(){}捕捉异常，人工抛出异常，
 * 				也可以自定义异常类
 * 
 * 		集合是用来存放对象 的
 * 			包括set   无序不可重复    add添加  remove移除数据
 * 				set集合可以存null
 * 			treeset可以根据值排序
 * 
 * 		泛型：让集合只能存同样的类型的对象
 * 
 * 
 * 
 * 		Treeset:自然排序和定制排序，一般情况下都是自然排序，定制排序的话需要实现一个comparator接口	
 * 				原理：调动compare to（）方法		day10.test4
 * 			使用treeset的时候必须保证放入同类型的对象，此处用泛型进行限制
 * 
 * 		
 * 
 * 		List集合代表有序可重复的几个  
 * 
 * 		ArrayList是list接口的一个实现，线程不安全的，但是可以用别的方法实现线程安全
 * 		vector也是list接口 的一个实现，线程安全的，不推荐使用
 *  		list的方法在   day10 test5  中详细说明
 * 		
 * 
 * 
 * 		Map集合：用于保存具有映射关系的集合，键值对
 * 		Map接口主要由hashMap实现
 * 		HashTable和HashMap差不多，前者比较古老
 * 
 * 		TreeMap可以根据存入键值对的key进行排序，也可以进行定制排序
 * 		
 * 		
 * 
 * 		工具类collections
 * 			使用方法在day10 test7详细讲解
 * 
 * 
 * 		java中的泛型只在编译的时候生效，泛型信息不会进入到运行阶段
 * 		泛型类：
 * 			class A<T>{
 * 			
 * 			}
 * 		泛型接口:
 *     		interface A<T>{
 *     		
 *     		}
 * 		定义泛型方法：
 * 			public void test{<T> t}
 * 			在public 后面加上想要定义的泛型<T>
 * 			就是public <T> void test{<T> t}
 * 
 * 
 * 		在类上定义的泛型可以在普通的方法（就是没有被static修饰的方法）中使用比如class C<E>{
 * 									private <E> e
 * 									.....
 * 									sys...(this.e)		
 * 										}
 * 			泛型方法在调用前没有固定的数据类型，在调用后传入的参数是什么类型就会把泛型改成什么类型
 * 			
 * 
 * 		List集合如果不定义泛型可以随意往里面写东西，各种数据类型的，是类型不安全的
 * 		泛型信息只在编译时有效。是不会进入运行时期的
 * 		
 * 		
 * 		在静态方法中，不能使用类定义泛型，只能使用静态方法自己定义的泛型
 * 		
 * 			
 * 
 * 		
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * */
